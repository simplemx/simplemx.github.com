前几个月刚开始做项目的时候，因为我们是做贵州省份的项目，而同类项目里做的最好的是苏州，局方经常说江苏的网站有多快，做的有多好，后来还发了些资料给我参考。

这几天趁时间刚好有点多，于是看了下江苏的网站，然后发现，他们是使用了BigPipe。

BigPipe是由Facebook开始推广，然后现在不少国内网站都开始采取这种模式，比如新浪微博等。当看到Facebook在2010年左右和BigPipe相关的资料的时候，不禁感叹，国内大多数网站要追上国外的，还要好多时间。

其实整个BigPipe的思想很简单。

首先，传统的浏览器和服务器的交互是大概这样的，浏览器发起请求，然后服务器根据这个请求拼装成对应的html等内容返回到浏览器，然后浏览器根据这些内容去渲染页面、加载css、js、图片等。

这个过程里，对于微博等sns网站来说，是比较坑爹的，首先这些网站本来页面模块就比较多，而且很多模块都需要动态的获取用户相关数据，所以整个页面渲染的话本来就有可能比较慢，造成用户访问的时候需要等待页面html返回，而且这些页面内容多的同事，js、css、图片等资源本来也不少，就算浏览器接收到了这些html了，还要加载这些静态资源，这里也是比较费时的，如果用户的网络本来就比较差了，这一整个过程肯定比较慢了。用户体验肯定比较差。

为了解决这个问题，除了后台更快响应之外，前端还是可以做不少事情的，比如可以采用分模块的方式，利用ajax加载各个模块，这样用户可以首先看到个主要的页面，然后等待模块加载完就可以和正常的流程一样做操作了。

但是使用ajax加载模块有个坏处，每一个ajax请求就需要对浏览器发起一个请求，本来一个请求完成的事情却需要多个请求了，服务器侧性能肯定会大打折扣，而且请求多了对前端也不是好处。这个时候，还可以使用长连接等方式，不过，长连接的话兼容性会是个问题。

这时候就可以使用BigPipe了。所谓的BigPipe简单点说就是将页面分模块然后分模块将内容传到用户。

这里还可以美其名为推送啊，长连接啊什么的，网上搜搜一大堆，但事实就是一个请求，和传统的一样，整个请求返回的所有内容也是类似的，只是BigPipe返回的内容是分块的，而传统返回的内容是一个正常的Html内容。

这里做个大概的例子，代码不一定能跑通,BigPipe返回的html内容大致是类似下面这样：

    <html>
    	<head>...</head>
    	<body>
    		<div id="content"></div>
    		<script type="application/javascript">
    			$(function(){$("#contnet").append("test content")})；
    		</script>
    	</body>
    </html>

而传统的html内容是大概这样：

    <html>
        <head>...</head>
        <body>
            <div id="content">
            	test content
            </div>
        </body>
    </html>

BigPipe的内容首先会有个占位的div，然后通过js来将实际的内容插入到对应的占位div内。而传统的则是整个html返回过来。从上面看不出有什么原因要这样做，而且，何来BigPipe的是分块的呢？

是这样的，BigPipe上面的内容再该次请求的时候是分块返回到浏览器的，首先占位的部分是先通过一个块返回到浏览器，然后浏览器收到这些内容就进行页面渲染，然后后面的脚本部分是第二个块，浏览器再接受到第二个块之后再讲内容插入到之前已经渲染好的div内。

所以，BigPipe的一次请求就将页面的多个模块按照分块的方式返回到浏览器，浏览器在收到这些块的时候就进行处理，一个块的内容和处理肯定比整个页面的少，所以响应服务器的时间就少了好多，普通情况下都是将简单的整个页面模板通过第一个块返回到浏览器，浏览器马上就将这个页面进行渲染了，这时候服务器同时还在处理着各个子模块的内容，并且返回过来，同时浏览器也在渲染请求，就不会干等了。

这时候，你可能会想，那这些所谓的分块是怎么实现的，这个就利用了http协议里的chunked encoding了，用请求捕捉工具捕捉请求，或者你会发现有些返回的报文里包含了：

    Transfer-Encoding:chunked

对的，BigPipe的实现完全就是基于这个chunked encoding。一般服务器返回的内容都会带上content-length，告诉浏览器这次返回的内容会有多长，这样的话，服务器首先必须要知道返回的内容，也就是必须要等待返回内容都生成好之后才能返回，但是如果是使用chunked encoding的话，则可以分批的将内容返回给用户，所谓的分批，大致是类似下面这样的方式：

    5
    12345

    2
    12

上面的5代表了后面有5长度内容，2代表了后面有2长度的内容，浏览器根据这种格式将返回的内容获取出来，所以服务器在获取到部分内容的时候就可以通过这种方式先将部分内容返回到浏览器，让浏览器先渲染一部分内容。而如果返回的内容没有了服务器怎么通知浏览器呢？很简单，服务器返回个0就可以了，代表后面没有任何数据了。

所以利用chunked encoding，服务器可以将本来很长的内容分批的返回给浏览器，浏览器分批的获取到内容然后进行展示，减少了响应时间，从而使页面比传统的快。